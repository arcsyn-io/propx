
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lucaskalb/rapidx/gen/array.go (54.7%)</option>
				
				<option value="file1">github.com/lucaskalb/rapidx/gen/bool.go (76.3%)</option>
				
				<option value="file2">github.com/lucaskalb/rapidx/gen/comb.go (37.8%)</option>
				
				<option value="file3">github.com/lucaskalb/rapidx/gen/cpf.go (77.9%)</option>
				
				<option value="file4">github.com/lucaskalb/rapidx/gen/float.go (71.7%)</option>
				
				<option value="file5">github.com/lucaskalb/rapidx/gen/float64.go (89.9%)</option>
				
				<option value="file6">github.com/lucaskalb/rapidx/gen/int.go (96.3%)</option>
				
				<option value="file7">github.com/lucaskalb/rapidx/gen/int64.go (80.2%)</option>
				
				<option value="file8">github.com/lucaskalb/rapidx/gen/slice.go (96.2%)</option>
				
				<option value="file9">github.com/lucaskalb/rapidx/gen/string.go (79.1%)</option>
				
				<option value="file10">github.com/lucaskalb/rapidx/gen/types.go (100.0%)</option>
				
				<option value="file11">github.com/lucaskalb/rapidx/gen/uint.go (81.3%)</option>
				
				<option value="file12">github.com/lucaskalb/rapidx/gen/uint64.go (94.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gen

import "math/rand"

// ArrayOf gera um slice de comprimento **exato** n, usando o gerador de elementos.
// Ele é “array-like”: ótimo quando você precisa simular [N]T.
// Shrink: não pode remover elementos; apenas tenta shrink local em cada posição,
// explorando múltiplos ramos (BFS/DFS) e deduplicando candidatos.
func ArrayOf[T any](elem Generator[T], n int) Generator[[]T] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, _ Size) ([]T, Shrinker[[]T]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{ n = 0 }</span>

                // gera valores + shrinkers dos elementos
                <span class="cov8" title="1">cur := make([]T, n)
                elS := make([]Shrinker[T], n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        v, s := elem.Generate(r, Size{})
                        cur[i], elS[i] = v, s
                }</span>

                <span class="cov8" title="1">queue := make([][]T, 0, 32)
                seen  := map[string]struct{}{sig(cur): {}}
                var last []T

                push := func(s []T) </span><span class="cov8" title="1">{
                        k := sig(s)
                        if _, ok := seen[k]; ok </span><span class="cov0" title="0">{ return }</span>
                        <span class="cov8" title="1">seen[k] = struct{}{}
                        cp := append(([]T)(nil), s...)
                        queue = append(queue, cp)</span>
                }

                // Gera vizinhos tentando “amansar” cada posição com um passo de shrink local
                <span class="cov8" title="1">grow := func(base []T) </span><span class="cov8" title="1">{
                        queue = queue[:0]
                        L := len(base)
                        for i := L-1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                if elS[i] == nil </span><span class="cov0" title="0">{ continue</span> }
                                <span class="cov8" title="1">if nv, ok := elS[i](false); ok </span><span class="cov8" title="1">{ // propõe 1 candidato para a posição i
                                        cand := append(([]T)(nil), base...)
                                        cand[i] = nv
                                        push(cand)
                                }</span>
                        }
                }
                <span class="cov8" title="1">grow(cur)

                pop := func() ([]T, bool) </span><span class="cov0" title="0">{
                        if len(queue) == 0 </span><span class="cov0" title="0">{ return nil, false }</span>
                        <span class="cov0" title="0">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                                v := queue[len(queue)-1]
                                queue = queue[:len(queue)-1]
                                return v, true
                        }</span>
                        <span class="cov0" title="0">v := queue[0]
                        queue = queue[1:]
                        return v, true</span>
                }

                <span class="cov8" title="1">return cur, func(accept bool) ([]T, bool) </span><span class="cov0" title="0">{
                        if accept </span><span class="cov0" title="0">{
                                // rebase: novo mínimo passa a ser o último candidato aceito
                                if last != nil &amp;&amp; sig(last) != sig(cur) </span><span class="cov0" title="0">{
                                        cur = last
                                        // após rebase, “esquecemos” shrinkers elementares para manter simplicidade;
                                        // ainda assim, numa próxima camada grow() reproporá um passo por posição.
                                        for i := range elS </span><span class="cov0" title="0">{ elS[i] = nil }</span>
                                        <span class="cov0" title="0">grow(cur)</span>
                                }
                        }
                        <span class="cov0" title="0">nxt, ok := pop()
                        if !ok </span><span class="cov0" title="0">{ return nil, false }</span>
                        <span class="cov0" title="0">last = nxt
                        return nxt, true</span>
                }
        })
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package gen

import "math/rand"

// Bool gera valores booleanos uniformemente.
// Shrink: prioriza reduzir para false (contraexemplo “menor” por convenção).
func Bool() Generator[bool] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, _ Size) (bool, Shrinker[bool]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := r.Intn(2) == 0 // true/false
                cur, last := v, v

                queue := make([]bool, 0, 2)
                seen  := map[bool]struct{}{cur: {}}

                push := func(b bool) </span><span class="cov8" title="1">{
                        if _, ok := seen[b]; ok </span><span class="cov0" title="0">{ return }</span>
                        <span class="cov8" title="1">seen[b] = struct{}{}
                        queue = append(queue, b)</span>
                }

                <span class="cov8" title="1">grow := func(base bool) </span><span class="cov8" title="1">{
                        queue = queue[:0]
                        // Heurística: tentar false primeiro
                        if base != false </span><span class="cov8" title="1">{ push(false) }</span>
                        <span class="cov8" title="1">if base != true  </span><span class="cov8" title="1">{ push(true)  }</span>
                }
                <span class="cov8" title="1">grow(cur)

                pop := func() (bool, bool) </span><span class="cov8" title="1">{
                        if len(queue) == 0 </span><span class="cov0" title="0">{ return false, false }</span>
                        <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                                v := queue[len(queue)-1]
                                queue = queue[:len(queue)-1]
                                return v, true
                        }</span>
                        <span class="cov8" title="1">v := queue[0]
                        queue = queue[1:]
                        return v, true</span>
                }

                <span class="cov8" title="1">return cur, func(accept bool) (bool, bool) </span><span class="cov8" title="1">{
                        if accept &amp;&amp; last != cur </span><span class="cov0" title="0">{
                                cur = last
                                grow(cur)
                        }</span>
                        <span class="cov8" title="1">nxt, ok := pop()
                        if !ok </span><span class="cov0" title="0">{ return false, false }</span>
                        <span class="cov8" title="1">last = nxt
                        return nxt, true</span>
                }
        })
}

</pre>
		
		<pre class="file" id="file2" style="display: none">// File: gen/comb.go
package gen

import (
        "math/rand"

)

// -------------------------
// Helpers básicos
// -------------------------

// Const retorna sempre o mesmo valor (sem shrinking).
func Const[T any](v T) Generator[T] <span class="cov8" title="1">{
        return From(func(_ *rand.Rand, _ Size) (T, Shrinker[T]) </span><span class="cov8" title="1">{
                return v, func(bool) (T, bool) </span><span class="cov0" title="0">{ var z T; return z, false }</span>
        })
}

// OneOf escolhe uniformemente um dos geradores.
func OneOf[T any](gs ...Generator[T]) Generator[T] <span class="cov8" title="1">{
        return Weighted(func(_ T) float64 </span><span class="cov0" title="0">{ return 1.0 }</span>, gs...)
}

// Weighted escolhe um gerador com base em pesos dinâmicos (por valor).
// A estratégia aqui captura qual índice foi selecionado para poder “shrincar”
// reusando o shrinker do gerador escolhido. Opcionalmente, no shrinking
// também tenta migrar para vizinhos (outros índices) — controlado por `tryNeighbors`.
func Weighted[T any](weight func(T) float64, gs ...Generator[T]) Generator[T] <span class="cov8" title="1">{
        if len(gs) == 0 </span><span class="cov0" title="0">{
                panic("gen.Weighted: precisa de ao menos um gerador")</span>
        }
        <span class="cov8" title="1">return From(func(r *rand.Rand, sz Size) (T, Shrinker[T]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                // etapa 1: escolher gerador
                <span class="cov8" title="1">idx := r.Intn(len(gs))
                val, shrink := gs[idx].Generate(r, sz)

                // fila de vizinhos (outros geradores) para tentar durante shrinking
                neighbors := make([]int, 0, len(gs)-1)
                for i := range gs </span><span class="cov8" title="1">{
                        if i != idx </span><span class="cov8" title="1">{
                                neighbors = append(neighbors, i)
                        }</span>
                }

                <span class="cov8" title="1">return val, func(accept bool) (T, bool) </span><span class="cov0" title="0">{
                        // se o último candidato foi aceito (falhou), continuamos shrink do mesmo gerador
                        if accept </span><span class="cov0" title="0">{
                                if next, ok := shrink(true); ok </span><span class="cov0" title="0">{
                                        return next, true
                                }</span>
                                // esgotou o shrink interno → tenta migrar para um vizinho
                                <span class="cov0" title="0">for len(neighbors) &gt; 0 </span><span class="cov0" title="0">{
                                        j := neighbors[0]
                                        neighbors = neighbors[1:]
                                        nv, ns := gs[j].Generate(r, sz)
                                        // atualiza “contexto” para o novo gerador
                                        idx, val, shrink = j, nv, ns
                                        return val, true
                                }</span>
                                <span class="cov0" title="0">var z T
                                return z, false</span>
                        }
                        // candidato foi rejeitado → tente outro do mesmo shrinker
                        <span class="cov0" title="0">if next, ok := shrink(false); ok </span><span class="cov0" title="0">{
                                return next, true
                        }</span>
                        // ou migre para um vizinho
                        <span class="cov0" title="0">for len(neighbors) &gt; 0 </span><span class="cov0" title="0">{
                                j := neighbors[0]
                                neighbors = neighbors[1:]
                                nv, ns := gs[j].Generate(r, sz)
                                idx, val, shrink = j, nv, ns
                                return val, true
                        }</span>
                        <span class="cov0" title="0">var z T
                        return z, false</span>
                }
        })
}

// -------------------------
// Combinadores
// -------------------------

// Map aplica f: A -&gt; B preservando o shrinking (mapeia os candidatos de A).
func Map[A, B any](ga Generator[A], f func(A) B) Generator[B] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (B, Shrinker[B]) </span><span class="cov8" title="1">{
                a, sa := ga.Generate(r, sz)
                b := f(a)
                return b, func(accept bool) (B, bool) </span><span class="cov0" title="0">{
                        na, ok := sa(accept)
                        if !ok </span><span class="cov0" title="0">{
                                var z B
                                return z, false
                        }</span>
                        <span class="cov0" title="0">return f(na), true</span>
                }
        })
}

// Filter mantém apenas valores que satisfazem pred.
// Implementa “rebase” no shrink: quando aceita, shrinka em cima do novo mínimo
// garantindo que os próximos candidatos também satisfaçam o predicado.
func Filter[T any](g Generator[T], pred func(T) bool, maxTries int) Generator[T] <span class="cov8" title="1">{
        if maxTries &lt;= 0 </span><span class="cov0" title="0">{
                maxTries = 1000
        }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, sz Size) (T, Shrinker[T]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                // gerar um valor que passe no pred
                <span class="cov8" title="1">var v T
                var s Shrinker[T]
                okv := false
                for tries := 0; tries &lt; maxTries; tries++ </span><span class="cov8" title="1">{
                        v, s = g.Generate(r, sz)
                        if pred(v) </span><span class="cov8" title="1">{
                                okv = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !okv </span><span class="cov0" title="0">{
                        var z T
                        return z, func(bool) (T, bool) </span><span class="cov0" title="0">{ return z, false }</span>
                }

                // shrinker: sempre que aceitar, precisamos “rebasear” e continuar
                // garantindo pred nos próximos candidatos.
                <span class="cov8" title="1">return v, func(accept bool) (T, bool) </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                nv, ok := s(accept)
                                if !ok </span><span class="cov0" title="0">{
                                        var z T
                                        return z, false
                                }</span>
                                <span class="cov0" title="0">if pred(nv) </span><span class="cov0" title="0">{
                                        return nv, true
                                }</span>
                                // candidato não cumpre pred → rejeita e tenta próximo
                                <span class="cov0" title="0">accept = false</span>
                        }
                }
        })
}

// Bind (flatMap): o gerador de saída depende do valor gerado em A.
// Shrinking: primeiro tenta shrink em B; quando esgota, shrink em A e regenera B.
func Bind[A, B any](ga Generator[A], f func(A) Generator[B]) Generator[B] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (B, Shrinker[B]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                <span class="cov8" title="1">a, sa := ga.Generate(r, sz)
                gb := f(a)
                b, sb := gb.Generate(r, sz)

                state := 0 // 0 =&gt; shrink B; 1 =&gt; shrink A (e regenerar B)

                return b, func(accept bool) (B, bool) </span><span class="cov0" title="0">{
                        switch state </span>{
                        case 0:<span class="cov0" title="0">
                                if nb, ok := sb(accept); ok </span><span class="cov0" title="0">{
                                        return nb, true
                                }</span>
                                // esgotou shrink de B → partimos para shrink de A
                                <span class="cov0" title="0">state = 1
                                accept = false // primeiro passo em A é “rejeitar” para pegar próximo candidato
                                fallthrough</span>
                        case 1:<span class="cov0" title="0">
                                na, ok := sa(accept)
                                if !ok </span><span class="cov0" title="0">{
                                        var z B
                                        return z, false
                                }</span>
                                // regenerar B com base no novo A
                                <span class="cov0" title="0">a = na
                                gb = f(a)
                                b, sb = gb.Generate(r, sz)
                                return b, true</span>
                        default:<span class="cov0" title="0">
                                var z B
                                return z, false</span>
                        }
                }
        })
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package gen

import (
        "errors"
        "math/rand"
        "strings"
        "unicode"
)

// CPF válido; masked controla formato.
func CPF(masked bool) Generator[string] <span class="cov8" title="1">{
    return From(func(r *rand.Rand, _ Size) (string, Shrinker[string]) </span><span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>

        // gera raiz 0..9 evitando todos iguais
        <span class="cov8" title="1">root := make([]byte, 9)
        for </span><span class="cov8" title="1">{
            for i := range 9 </span><span class="cov8" title="1">{ root[i] = byte(r.Intn(10)) }</span>
            <span class="cov8" title="1">if !allSameDigits(root) </span><span class="cov8" title="1">{ break</span> }
        }
        <span class="cov8" title="1">d1, d2 := computeCPFVerifiersBytes(root)

        raw := make([]byte, 0, 11)
        for _, n := range root </span><span class="cov8" title="1">{ raw = append(raw, '0'+n) }</span>
        <span class="cov8" title="1">raw = append(raw, d1, d2)

        cur := string(raw)
        if masked </span><span class="cov0" title="0">{ cur = MaskCPF(cur) }</span>

        // ---------- SHRINK MULTI-RAMO COM HEURÍSTICA ----------
        <span class="cov8" title="1">queue := make([]string, 0, 32)
        seen  := make(map[string]struct{}, 64) // dedup
        var last string                         // último proposto

        push := func(s string) </span><span class="cov8" title="1">{
            if _, ok := seen[s]; ok </span><span class="cov8" title="1">{ return }</span>
            <span class="cov8" title="1">seen[s] = struct{}{}
            queue = append(queue, s)</span>
        }

        // monta vizinhos priorizando: unmask -&gt; zero(i L-&gt;R) -&gt; dec(j R-&gt;L)
        <span class="cov8" title="1">growNeighbors := func(base string) </span><span class="cov8" title="1">{
            queue = queue[:0] // reset da fila; manter 'seen' evita loops
            un := UnmaskCPF(base)

            // (1) unmask primeiro (se aplicável)
            if base != un </span><span class="cov0" title="0">{ push(un) }</span>

            // raiz como 0..9
            <span class="cov8" title="1">r9 := make([]byte, 9)
            for i := range 9 </span><span class="cov8" title="1">{ r9[i] = un[i]-'0' }</span>

            // (2) zerar dígitos L-&gt;R
            <span class="cov8" title="1">for i := range 9 </span><span class="cov8" title="1">{
                if r9[i] == 0 </span><span class="cov0" title="0">{ continue</span> }
                <span class="cov8" title="1">orig := r9[i]
                r9[i] = 0
                if !allSameDigits(r9) </span><span class="cov8" title="1">{
                    d1, d2 := computeCPFVerifiersBytes(r9)
                    buf := make([]byte, 0, 11)
                    for _, n := range r9 </span><span class="cov8" title="1">{ buf = append(buf, '0'+n) }</span>
                    <span class="cov8" title="1">buf = append(buf, d1, d2)
                    push(string(buf))</span>
                }
                <span class="cov8" title="1">r9[i] = orig</span>
            }

            // (3) decrementar dígitos R-&gt;L (mais “local”)
            <span class="cov8" title="1">for j := 8; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if r9[j] == 0 </span><span class="cov0" title="0">{ continue</span> }
                <span class="cov8" title="1">r9[j]--
                if !allSameDigits(r9) </span><span class="cov8" title="1">{
                    d1, d2 := computeCPFVerifiersBytes(r9)
                    buf := make([]byte, 0, 11)
                    for _, n := range r9 </span><span class="cov8" title="1">{ buf = append(buf, '0'+n) }</span>
                    <span class="cov8" title="1">buf = append(buf, d1, d2)
                    push(string(buf))</span>
                }
                <span class="cov8" title="1">r9[j]++</span>
            }
        }

        // seed inicial
        <span class="cov8" title="1">seen[cur] = struct{}{}
        growNeighbors(cur)

        popNext := func() (string, bool) </span><span class="cov0" title="0">{
            if len(queue) == 0 </span><span class="cov0" title="0">{ return "", false }</span>
            <span class="cov0" title="0">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                // LIFO
                v := queue[len(queue)-1]
                queue = queue[:len(queue)-1]
                return v, true
            }</span>
            // BFS: FIFO
            <span class="cov0" title="0">v := queue[0]
            queue = queue[1:]
            return v, true</span>
        }

        // shrinker com feedback: accept==true -&gt; rebase em 'last' e regen vizinhos
        <span class="cov8" title="1">return cur, func(accept bool) (string, bool) </span><span class="cov0" title="0">{
            if accept </span><span class="cov0" title="0">{
                // o último candidato manteve a falha -&gt; vira novo mínimo
                if last != "" &amp;&amp; last != cur </span><span class="cov0" title="0">{
                    cur = last
                    growNeighbors(cur)
                }</span>
            }
            // pegar próximo vizinho para tentar
            <span class="cov0" title="0">nxt, ok := popNext()
            if !ok </span><span class="cov0" title="0">{ return "", false }</span>
            <span class="cov0" title="0">last = nxt
            return nxt, true</span>
        }
    })
}


// CPFAny 50/50 com/sem máscara
func CPFAny() Generator[string] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (string, Shrinker[string]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                <span class="cov8" title="1">if r.Intn(2) == 0 </span><span class="cov0" title="0">{
                        return CPF(true).Generate(r, sz)
                }</span>
                <span class="cov8" title="1">return CPF(false).Generate(r, sz)</span>
        })
}

// ---------- utils domínio e helpers (iguais aos anteriores) ----------

func ValidCPF(s string) bool <span class="cov8" title="1">{
        raw := UnmaskCPF(s)
        if len(raw) != 11 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">b := []byte(raw)
        if allSame(b) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">d1, d2 := computeCPFVerifiers(b[:9])
        return b[9] == d1 &amp;&amp; b[10] == d2</span>
}

func MaskCPF(raw string) string <span class="cov8" title="1">{
        raw = UnmaskCPF(raw)
        if len(raw) != 11 </span><span class="cov0" title="0">{
                panic(errors.New("MaskCPF: precisa de 11 dígitos"))</span>
        }
        <span class="cov8" title="1">return raw[0:3] + "." + raw[3:6] + "." + raw[6:9] + "-" + raw[9:11]</span>
}

func UnmaskCPF(s string) string <span class="cov8" title="1">{
        var b strings.Builder
        b.Grow(len(s))
        for _, r := range s </span><span class="cov8" title="1">{
                if unicode.IsDigit(r) </span><span class="cov8" title="1">{
                        b.WriteByte(byte((int(r) - int('0')) + int('0')))
                }</span>
        }
        <span class="cov8" title="1">return b.String()</span>
}

func allSame(b []byte) bool <span class="cov8" title="1">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">f := b[0]
        for _, x := range b[1:] </span><span class="cov8" title="1">{
                if x != f </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
func allSameDigits(b []byte) bool <span class="cov8" title="1">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">f := b[0]
        for _, x := range b[1:] </span><span class="cov8" title="1">{
                if x != f </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func computeCPFVerifiers(root []byte) (d1, d2 byte) <span class="cov8" title="1">{
        if len(root) != 9 </span><span class="cov0" title="0">{
                panic(errors.New("computeCPFVerifiers: root len != 9"))</span>
        }
        <span class="cov8" title="1">sum := 0
        for i := range 9 </span><span class="cov8" title="1">{
                sum += int(root[i]-'0') * (10 - i)
        }</span>
        <span class="cov8" title="1">rest := sum % 11
        if rest &lt; 2 </span><span class="cov0" title="0">{
                d1 = '0'
        }</span> else<span class="cov8" title="1"> {
                d1 = byte(11-rest) + '0'
        }</span>

        <span class="cov8" title="1">sum = 0
        for i := range 9 </span><span class="cov8" title="1">{
                sum += int(root[i]-'0') * (11 - i)
        }</span>
        <span class="cov8" title="1">sum += int(d1-'0') * 2
        rest = sum % 11
        if rest &lt; 2 </span><span class="cov0" title="0">{
                d2 = '0'
        }</span> else<span class="cov8" title="1"> {
                d2 = byte(11-rest) + '0'
        }</span>
        <span class="cov8" title="1">return</span>
}
func computeCPFVerifiersBytes(root []byte) (d1, d2 byte) <span class="cov8" title="1">{
        if len(root) != 9 </span><span class="cov0" title="0">{
                panic(errors.New("computeCPFVerifiersBytes: root len != 9"))</span>
        }
        <span class="cov8" title="1">sum := 0
        for i := range 9 </span><span class="cov8" title="1">{
                sum += int(root[i]) * (10 - i)
        }</span>
        <span class="cov8" title="1">rest := sum % 11
        if rest &lt; 2 </span><span class="cov8" title="1">{
                d1 = '0'
        }</span> else<span class="cov8" title="1"> {
                d1 = byte(11-rest) + '0'
        }</span>

        <span class="cov8" title="1">sum = 0
        for i := range 9 </span><span class="cov8" title="1">{
                sum += int(root[i]) * (11 - i)
        }</span>
        <span class="cov8" title="1">sum += int(d1-'0') * 2
        rest = sum % 11
        if rest &lt; 2 </span><span class="cov8" title="1">{
                d2 = '0'
        }</span> else<span class="cov8" title="1"> {
                d2 = byte(11-rest) + '0'
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gen

import (
        "math"
        "math/rand"
)

// Float32 gera floats32 com faixa automática a partir de Size.
// Default: [-100, 100]. Não inclui NaN/Inf.
func Float32(size Size) Generator[float32] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (float32, Shrinker[float32]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">min, max := autoRangeF32(size, sz)
                if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
                <span class="cov8" title="1">v := uniformF32(r, min, max)
                return float32ShrinkInit(v, min, max, false, false)</span>
        })
}

// Float32Range gera float32 em [min, max]; pode opcionalmente produzir NaN/±Inf.
func Float32Range(min, max float32, includeNaN, includeInf bool) Generator[float32] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (float32, Shrinker[float32]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := uniformF32(r, min, max)
                if includeNaN &amp;&amp; r.Intn(50) == 0 </span><span class="cov0" title="0">{
                        v = float32(math.NaN())
                }</span> else<span class="cov8" title="1"> if includeInf &amp;&amp; r.Intn(50) == 1 </span><span class="cov0" title="0">{
                        if r.Intn(2) == 0 </span><span class="cov0" title="0">{ v = float32(math.Inf(+1)) }</span> else<span class="cov0" title="0"> { v = float32(math.Inf(-1)) }</span>
                }
                <span class="cov8" title="1">return float32ShrinkInit(v, min, max, includeNaN, includeInf)</span>
        })
}

// -------------- impl / shrinking (float32) --------------

func float32ShrinkInit(start, min, max float32, allowNaN, allowInf bool) (float32, Shrinker[float32]) <span class="cov8" title="1">{
        cur := clampF32(start, min, max)
        last := cur

        queue := make([]float32, 0, 32)
        seen  := map[uint32]struct{}{f32key(cur): {}}

        push := func(x float32) </span><span class="cov8" title="1">{
                if float32IsNaN(x) &amp;&amp; !allowNaN </span><span class="cov0" title="0">{ return }</span>
                <span class="cov8" title="1">if float32IsInf(x) &amp;&amp; !allowInf </span><span class="cov0" title="0">{ return }</span>
                <span class="cov8" title="1">if float32IsFinite(x) &amp;&amp; float32IsFinite(min) &amp;&amp; float32IsFinite(max) </span><span class="cov8" title="1">{
                        if x &lt; min || x &gt; max </span><span class="cov8" title="1">{ return }</span>
                }
                <span class="cov8" title="1">k := f32key(x)
                if _, ok := seen[k]; ok </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">seen[k] = struct{}{}
                queue = append(queue, x)</span>
        }

        <span class="cov8" title="1">grow := func(base float32) </span><span class="cov8" title="1">{
                queue = queue[:0]

                if float32IsNaN(base) </span><span class="cov0" title="0">{
                        push(0)
                        push(1)
                        push(-1)
                        if allowInf </span><span class="cov0" title="0">{ push(float32(math.Inf(+1))); push(float32(math.Inf(-1))) }</span>
                        <span class="cov0" title="0">if float32IsFinite(min) </span><span class="cov0" title="0">{ push(min) }</span>
                        <span class="cov0" title="0">if float32IsFinite(max) </span><span class="cov0" title="0">{ push(max) }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">if float32IsInf(base) </span><span class="cov0" title="0">{
                        if math.IsInf(float64(base), +1) &amp;&amp; float32IsFinite(max) </span><span class="cov0" title="0">{ push(max) }</span>
                        <span class="cov0" title="0">if math.IsInf(float64(base), -1) &amp;&amp; float32IsFinite(min) </span><span class="cov0" title="0">{ push(min) }</span>
                        <span class="cov0" title="0">push(0)
                        return</span>
                }

                // Finito
                <span class="cov8" title="1">target := float32Target(min, max)
                if base != target </span><span class="cov8" title="1">{ push(target) }</span>

                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        next := midpointTowardsF32(base, target)
                        if next != base </span><span class="cov8" title="1">{ push(next) }</span>
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8 &amp;&amp; series != target; i++ </span><span class="cov8" title="1">{
                                series = midpointTowardsF32(series, target)
                                if series != base </span><span class="cov8" title="1">{ push(series) }</span>
                        }
                }

                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        step := math.Nextafter32(base, target)
                        if step != base </span><span class="cov8" title="1">{ push(step) }</span>
                }

                // tentar flipar sinal se alvo=0
                <span class="cov8" title="1">if target == 0 &amp;&amp; base != 0 </span><span class="cov8" title="1">{
                        push(-base)
                }</span>

                <span class="cov8" title="1">if float32IsFinite(min) &amp;&amp; base != min </span><span class="cov8" title="1">{ push(min) }</span>
                <span class="cov8" title="1">if float32IsFinite(max) &amp;&amp; base != max </span><span class="cov8" title="1">{ push(max) }</span>
        }

        <span class="cov8" title="1">grow(cur)

        pop := func() (float32, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (float32, bool) </span><span class="cov8" title="1">{
                if accept &amp;&amp; f32key(last) != f32key(cur) </span><span class="cov0" title="0">{
                        cur = last
                        grow(cur)
                }</span>
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

// ---------- helpers float32 ----------

func float32IsFinite(x float32) bool <span class="cov8" title="1">{ return !math.IsNaN(float64(x)) &amp;&amp; !math.IsInf(float64(x), 0) }</span>
func float32IsNaN(x float32) bool    <span class="cov8" title="1">{ return math.IsNaN(float64(x)) }</span>
func float32IsInf(x float32) bool    <span class="cov8" title="1">{ return math.IsInf(float64(x), 0) }</span>

func f32key(x float32) uint32 <span class="cov8" title="1">{ return math.Float32bits(x) }</span>

func clampF32(x, min, max float32) float32 <span class="cov8" title="1">{
        if !float32IsFinite(x) </span><span class="cov0" title="0">{ return x }</span>
        <span class="cov8" title="1">if float32IsFinite(min) &amp;&amp; x &lt; min </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov8" title="1">if float32IsFinite(max) &amp;&amp; x &gt; max </span><span class="cov8" title="1">{ return max }</span>
        <span class="cov8" title="1">return x</span>
}

func autoRangeF32(local, fromRunner Size) (float32, float32) <span class="cov8" title="1">{
        M := 0
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                if a := absInt(s.Min); a &gt; M </span><span class="cov0" title="0">{ M = a }</span>
                <span class="cov8" title="1">if a := absInt(s.Max); a &gt; M </span><span class="cov8" title="1">{ M = a }</span>
        }
        <span class="cov8" title="1">if M == 0 </span><span class="cov8" title="1">{ M = 100 }</span>
        <span class="cov8" title="1">return -float32(M), float32(M)</span>
}

func uniformF32(r *rand.Rand, min, max float32) float32 <span class="cov8" title="1">{
        if float32IsFinite(min) &amp;&amp; float32IsFinite(max) &amp;&amp; max &gt;= min </span><span class="cov8" title="1">{
                if min == max </span><span class="cov0" title="0">{ return min }</span>
                <span class="cov8" title="1">return min + float32(r.Float64())*(max-min)</span>
        }
        <span class="cov0" title="0">return -100 + float32(r.Float64())*200</span>
}

func float32Target(min, max float32) float32 <span class="cov8" title="1">{
        if float32IsFinite(min) &amp;&amp; float32IsFinite(max) &amp;&amp; min &lt;= 0 &amp;&amp; 0 &lt;= max </span><span class="cov8" title="1">{ return 0 }</span>
        <span class="cov8" title="1">if !float32IsFinite(min) &amp;&amp; !float32IsFinite(max) </span><span class="cov0" title="0">{ return 0 }</span>
        <span class="cov8" title="1">amin := float32(math.Abs(float64(min)))
        amax := float32(math.Abs(float64(max)))
        if amin &lt; amax </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov8" title="1">return max</span>
}

func midpointTowardsF32(a, b float32) float32 <span class="cov8" title="1">{
        if a == b </span><span class="cov8" title="1">{ return a }</span>
        <span class="cov8" title="1">return a + (b-a)/2</span>
}

</pre>
		
		<pre class="file" id="file5" style="display: none">package gen

import (
        "math"
        "math/rand"
)

// Float64 gera floats com faixa automática a partir de Size.
// - Se nenhum Size informado, usa faixa [-100, 100].
// - Não inclui NaN/Inf (focados em casos numéricos de negócio).
func Float64(size Size) Generator[float64] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (float64, Shrinker[float64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">min, max := autoRangeF64(size, sz)
                if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
                <span class="cov8" title="1">v := uniformF64(r, min, max)
                return float64ShrinkInit(v, min, max, false, false)</span>
        })
}

func autoRangeF64(local, fromRunner Size) (float64, float64) <span class="cov8" title="1">{
        M := 0
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                if a := absInt(s.Min); a &gt; M </span><span class="cov8" title="1">{ M = a }</span>
                <span class="cov8" title="1">if a := absInt(s.Max); a &gt; M </span><span class="cov8" title="1">{ M = a }</span>
        }
        <span class="cov8" title="1">if M == 0 </span><span class="cov8" title="1">{ M = 100 }</span>
        <span class="cov8" title="1">return -float64(M), float64(M)</span>
}


// Float64Range gera floats uniformemente em [min, max] (inclusivo nos limites finitos).
// Parâmetros includeNaN/includeInf permitem injetar casos especiais.
func Float64Range(min, max float64, includeNaN, includeInf bool) Generator[float64] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (float64, Shrinker[float64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := uniformF64(r, min, max)
                // chance pequena de especiais, se habilitados
                if includeNaN &amp;&amp; r.Intn(50) == 0 </span><span class="cov0" title="0">{
                        v = math.NaN()
                }</span> else<span class="cov8" title="1"> if includeInf &amp;&amp; r.Intn(50) == 1 </span><span class="cov0" title="0">{
                        if r.Intn(2) == 0 </span><span class="cov0" title="0">{ v = math.Inf(+1) }</span> else<span class="cov0" title="0"> { v = math.Inf(-1) }</span>
                }
                <span class="cov8" title="1">return float64ShrinkInit(v, min, max, includeNaN, includeInf)</span>
        })
}

// ---------------- impl / shrinking ----------------

func float64ShrinkInit(start, min, max float64, allowNaN, allowInf bool) (float64, Shrinker[float64]) <span class="cov8" title="1">{
        cur := clampF64(start, min, max) // NaN fica como NaN; clamp não altera NaN
        last := cur

        queue := make([]float64, 0, 32)
        seen  := map[uint64]struct{}{f64key(cur): {}}

        push := func(x float64) </span><span class="cov8" title="1">{
                // respeita faixa quando finito; para Inf/NaN, empurra se permitidos
                if math.IsNaN(x) &amp;&amp; !allowNaN </span><span class="cov0" title="0">{ return }</span>
                <span class="cov8" title="1">if math.IsInf(x, 0) &amp;&amp; !allowInf </span><span class="cov0" title="0">{ return }</span>
                <span class="cov8" title="1">if isFinite(x) &amp;&amp; isFinite(min) &amp;&amp; isFinite(max) </span><span class="cov8" title="1">{
                        if x &lt; min || x &gt; max </span><span class="cov8" title="1">{ return }</span>
                }
                <span class="cov8" title="1">k := f64key(x)
                if _, ok := seen[k]; ok </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">seen[k] = struct{}{}
                queue = append(queue, x)</span>
        }

        <span class="cov8" title="1">grow := func(base float64) </span><span class="cov8" title="1">{
                queue = queue[:0]

                // Casos especiais primeiro
                if math.IsNaN(base) </span><span class="cov8" title="1">{
                        // NaN -&gt; tente 0, 1, -1, ±Inf (se permitido), limites
                        push(0)
                        push(1)
                        push(-1)
                        if allowInf </span><span class="cov0" title="0">{
                                push(math.Inf(+1))
                                push(math.Inf(-1))
                        }</span>
                        <span class="cov8" title="1">if isFinite(min) </span><span class="cov8" title="1">{ push(min) }</span>
                        <span class="cov8" title="1">if isFinite(max) </span><span class="cov8" title="1">{ push(max) }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">if math.IsInf(base, 0) </span><span class="cov8" title="1">{
                        // +Inf/-Inf -&gt; aproximar pelo limite apropriado, depois rumo a 0
                        if math.IsInf(base, +1) &amp;&amp; isFinite(max) </span><span class="cov8" title="1">{
                                push(max)
                        }</span>
                        <span class="cov8" title="1">if math.IsInf(base, -1) &amp;&amp; isFinite(min) </span><span class="cov0" title="0">{
                                push(min)
                        }</span>
                        <span class="cov8" title="1">push(0)
                        return</span>
                }

                // Finito: heurística normal rumo a 0
                <span class="cov8" title="1">target := float64Target(min, max) // 0 se possível; senão limite mais próximo de 0
                if base != target </span><span class="cov8" title="1">{ push(target) }</span>

                // Bisseções (metade do caminho até o alvo)
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        next := midpointTowardsF64(base, target)
                        if next != base </span><span class="cov8" title="1">{ push(next) }</span>
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8 &amp;&amp; series != target; i++ </span><span class="cov8" title="1">{
                                series = midpointTowardsF64(series, target)
                                if series != base </span><span class="cov8" title="1">{ push(series) }</span>
                        }
                }

                // Step em direção ao alvo usando Nextafter
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        step := math.Nextafter(base, target)
                        if step != base </span><span class="cov8" title="1">{ push(step) }</span>
                }

                // Tentar mudar sinal se isso aproxima de 0 (ex.: -x -&gt; +x quando target=0)
                <span class="cov8" title="1">if target == 0 &amp;&amp; base != 0 &amp;&amp; !math.Signbit(base) </span><span class="cov8" title="1">{
                        // base&gt;0: tente -base (pode não ser “menor” sempre, mas ajuda)
                        push(-base)
                }</span> else<span class="cov8" title="1"> if target == 0 &amp;&amp; base != 0 &amp;&amp; math.Signbit(base) </span><span class="cov8" title="1">{
                        push(-base)
                }</span>

                // Limites (se finitos)
                <span class="cov8" title="1">if isFinite(min) &amp;&amp; base != min </span><span class="cov8" title="1">{ push(min) }</span>
                <span class="cov8" title="1">if isFinite(max) &amp;&amp; base != max </span><span class="cov8" title="1">{ push(max) }</span>
        }

        <span class="cov8" title="1">grow(cur)

        pop := func() (float64, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov8" title="1">{ return 0, false }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov8" title="1">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (float64, bool) </span><span class="cov8" title="1">{
                if accept &amp;&amp; f64key(last) != f64key(cur) </span><span class="cov8" title="1">{
                        cur = last
                        grow(cur)
                }</span>
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov8" title="1">{ return 0, false }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

// ---------- helpers float64 ----------

func isFinite(x float64) bool <span class="cov8" title="1">{ return !math.IsNaN(x) &amp;&amp; !math.IsInf(x, 0) }</span>

func f64key(x float64) uint64 <span class="cov8" title="1">{ return math.Float64bits(x) }</span>

func clampF64(x, min, max float64) float64 <span class="cov8" title="1">{
        if !isFinite(x) </span><span class="cov8" title="1">{ return x }</span>
        <span class="cov8" title="1">if isFinite(min) &amp;&amp; x &lt; min </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov8" title="1">if isFinite(max) &amp;&amp; x &gt; max </span><span class="cov8" title="1">{ return max }</span>
        <span class="cov8" title="1">return x</span>
}

func uniformF64(r *rand.Rand, min, max float64) float64 <span class="cov8" title="1">{
        if isFinite(min) &amp;&amp; isFinite(max) &amp;&amp; max &gt;= min </span><span class="cov8" title="1">{
                if min == max </span><span class="cov8" title="1">{ return min }</span>
                <span class="cov8" title="1">return min + r.Float64()*(max-min)</span>
        }
        // se faixa inválida, cai no padrão [-100, 100]
        <span class="cov8" title="1">return -100 + r.Float64()*200</span>
}

// 0 dentro da faixa → alvo=0; senão limite mais próximo de 0
func float64Target(min, max float64) float64 <span class="cov8" title="1">{
        if isFinite(min) &amp;&amp; isFinite(max) &amp;&amp; min &lt;= 0 &amp;&amp; 0 &lt;= max </span><span class="cov8" title="1">{ return 0 }</span>
        // fora da faixa: pegue o bound mais próximo de 0
        <span class="cov8" title="1">if !isFinite(min) &amp;&amp; !isFinite(max) </span><span class="cov0" title="0">{ return 0 }</span>
        // escolher bound com menor |x|
        <span class="cov8" title="1">amin := math.Abs(min)
        amax := math.Abs(max)
        if amin &lt; amax </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov8" title="1">return max</span>
}

// passo de "bisseção" de a -&gt; b
func midpointTowardsF64(a, b float64) float64 <span class="cov8" title="1">{
        if a == b </span><span class="cov8" title="1">{ return a }</span>
        <span class="cov8" title="1">return a + (b-a)/2</span>
}


</pre>
		
		<pre class="file" id="file6" style="display: none">// File: gen/int.go
package gen

import (
        "math/rand"
)

// Int gera inteiros com faixa automática a partir de Size:
// - se sz.Max (ou |sz.Min|) &gt; 0: faixa := [-M, M], onde M = max(|sz.Min|, |sz.Max|)
// - caso contrário, usa faixa padrão [-100, 100].
// Ex.: prop.ForAll(t, cfg, gen.Int(gen.Size{Max: 1000})) ...
func Int(size Size) Generator[int] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (int, Shrinker[int]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                <span class="cov8" title="1">min, max := autoRange(size, sz) // decide a faixa efetiva
                if min &gt; max </span><span class="cov0" title="0">{
                        min, max = max, min
                }</span>
                // gera uniforme
                <span class="cov8" title="1">v := min + r.Intn(max-min+1)
                return intShrinkInit(v, min, max)</span>
        })
}

// IntRange gera inteiros uniformemente no intervalo [min, max] (inclusivo).
// Ignora sz para a faixa (útil quando você quer controle explícito).
func IntRange(min, max int) Generator[int] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov8" title="1">{
                min, max = max, min
        }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (int, Shrinker[int]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                <span class="cov8" title="1">v := min + r.Intn(max-min+1)
                return intShrinkInit(v, min, max)</span>
        })
}

// -------------------- implementação / shrinking --------------------

func intShrinkInit(start, min, max int) (int, Shrinker[int]) <span class="cov8" title="1">{
        // valor corrente (mínimo conhecido que falha) e último proposto
        cur := clamp(start, min, max)
        last := cur

        // fila de vizinhos + deduplicação
        queue := make([]int, 0, 16)
        seen := map[int]struct{}{cur: {}}

        push := func(x int) </span><span class="cov8" title="1">{
                if x &lt; min || x &gt; max </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if _, ok := seen[x]; ok </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">seen[x] = struct{}{}
                queue = append(queue, x)</span>
        }

        // heurística de vizinhos:
        //  1) aproximar do alvo (0 se estiver na faixa, senão limite mais próximo)
        //  2) “meio do caminho” em direção ao alvo (bisseção)
        //  3) passo unitário em direção ao alvo (+/-1)
        //  4) limites (min/max)
        <span class="cov8" title="1">growNeighbors := func(base int) </span><span class="cov8" title="1">{
                queue = queue[:0]
                target := shrinkTarget(min, max) // 0 se possível; senão bound mais próximo

                // (1) alvo direto
                if base != target </span><span class="cov8" title="1">{
                        push(target)
                }</span>

                // (2) meio do caminho em direção ao alvo (bisseção)
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        next := midpointTowards(base, target)
                        if next != base </span><span class="cov8" title="1">{
                                push(next)
                        }</span>
                        // múltiplas bisseções arredondando para longe de base
                        // (gera série base -&gt; base' -&gt; ... -&gt; target)
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                                if series == target </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">series = midpointTowards(series, target)
                                if series != base </span><span class="cov8" title="1">{
                                        push(series)
                                }</span>
                        }
                }

                // (3) passo unitário em direção ao alvo
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        step := stepTowards(base, target)
                        if step != base </span><span class="cov8" title="1">{
                                push(step)
                        }</span>
                }

                // (4) limites
                <span class="cov8" title="1">if base != min </span><span class="cov8" title="1">{
                        push(min)
                }</span>
                <span class="cov8" title="1">if base != max </span><span class="cov8" title="1">{
                        push(max)
                }</span>
        }

        <span class="cov8" title="1">growNeighbors(cur)

        pop := func() (int, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov8" title="1">{
                        return 0, false
                }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov8" title="1">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (int, bool) </span><span class="cov8" title="1">{
                // Se o último candidato foi ACEITO (continua falhando), rebaseie nele
                if accept </span><span class="cov8" title="1">{
                        if last != cur </span><span class="cov8" title="1">{
                                cur = last
                                growNeighbors(cur)
                        }</span>
                }
                // proponha o próximo vizinho
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov8" title="1">{
                        return 0, false
                }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

// shrinkTarget retorna o alvo “natural” para onde reduzir:
// - 0 se 0 ∈ [min,max]; caso contrário, o limite mais próximo de 0.
func shrinkTarget(min, max int) int <span class="cov8" title="1">{
        if min &lt;= 0 &amp;&amp; 0 &lt;= max </span><span class="cov8" title="1">{
                return 0
        }</span>
        // fora da faixa: pegue o bound mais próximo de 0
        <span class="cov8" title="1">if min &gt; 0 </span><span class="cov8" title="1">{
                // faixa toda positiva -&gt; min é o mais próximo de 0
                return min
        }</span>
        // faixa toda negativa -&gt; max é o mais próximo de 0 (ex.: [-10, -1] → -1)
        <span class="cov8" title="1">return max</span>
}

// midpointTowards dá um “passo de bisseção” de a em direção a b,
// com arredondamento para longe de 'a' para garantir progresso.
func midpointTowards(a, b int) int <span class="cov8" title="1">{
        if a == b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">d := b - a
        // arredonda “para cima” em magnitude para não travar quando |d| == 1
        step := d / 2
        if step == 0 </span><span class="cov8" title="1">{
                if d &gt; 0 </span><span class="cov8" title="1">{
                        step = 1
                }</span> else<span class="cov8" title="1"> {
                        step = -1
                }</span>
        }
        <span class="cov8" title="1">return a + step</span>
}

// stepTowards move um passo unitário de a em direção a b.
func stepTowards(a, b int) int <span class="cov8" title="1">{
        if a == b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">if b &gt; a </span><span class="cov8" title="1">{
                return a + 1
        }</span>
        <span class="cov8" title="1">return a - 1</span>
}

// autoRange decide a faixa final para Int(...) combinando o "size" local e o
// "size" vindo do runner. Preferimos o maior alcance informado; se nada for
// informado, usamos [-100, 100].
func autoRange(local, fromRunner Size) (int, int) <span class="cov8" title="1">{
        // escolha um "M" (magnitude) baseado no maior valor absoluto visto
        M := 0
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                M = maxInt(M, absInt(s.Min))
                M = maxInt(M, absInt(s.Max))
        }</span>
        <span class="cov8" title="1">if M == 0 </span><span class="cov8" title="1">{
                M = 100
        }</span>
        <span class="cov8" title="1">return -M, M</span>
}

func clamp(x, min, max int) int <span class="cov8" title="1">{
        if x &lt; min </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">if x &gt; max </span><span class="cov8" title="1">{
                return max
        }</span>
        <span class="cov8" title="1">return x</span>
}

func absInt(x int) int <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}
func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package gen

import (
        "math/rand"
)

// Int64 gera inteiros 64-bit com faixa automática baseada em Size.
// Se nenhum Size for informado, usa [-100, 100].
func Int64(size Size) Generator[int64] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (int64, Shrinker[int64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">min, max := autoRange64(size, sz)
                if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
                <span class="cov8" title="1">v := min + int64(r.Intn(int(max-min+1)))
                return int64ShrinkInit(v, min, max)</span>
        })
}

// Int64Range gera int64 uniformemente no intervalo [min, max] (inclusivo).
func Int64Range(min, max int64) Generator[int64] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (int64, Shrinker[int64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := min + int64(r.Intn(int(max-min+1)))
                return int64ShrinkInit(v, min, max)</span>
        })
}

// ---------------- impl / shrinking ----------------

func int64ShrinkInit(start, min, max int64) (int64, Shrinker[int64]) <span class="cov8" title="1">{
        cur, last := clamp64(start, min, max), clamp64(start, min, max)

        queue := make([]int64, 0, 16)
        seen  := map[int64]struct{}{cur: {}}

        push := func(x int64) </span><span class="cov8" title="1">{
                if x &lt; min || x &gt; max </span><span class="cov0" title="0">{ return }</span>
                <span class="cov8" title="1">if _, ok := seen[x]; ok </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">seen[x] = struct{}{}
                queue = append(queue, x)</span>
        }
        <span class="cov8" title="1">target := shrinkTarget64(min, max)

        grow := func(base int64) </span><span class="cov8" title="1">{
                queue = queue[:0]
                // (1) alvo (0 se dentro da faixa; senão bound + próximo)
                if base != target </span><span class="cov8" title="1">{ push(target) }</span>
                // (2) bisseções rumo ao alvo
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{
                        next := midpointTowards64(base, target)
                        if next != base </span><span class="cov8" title="1">{ push(next) }</span>
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8 &amp;&amp; series != target; i++ </span><span class="cov8" title="1">{
                                series = midpointTowards64(series, target)
                                if series != base </span><span class="cov8" title="1">{ push(series) }</span>
                        }
                }
                // (3) passo unitário
                <span class="cov8" title="1">if base != target </span><span class="cov8" title="1">{ push(stepTowards64(base, target)) }</span>
                // (4) limites
                <span class="cov8" title="1">if base != min </span><span class="cov8" title="1">{ push(min) }</span>
                <span class="cov8" title="1">if base != max </span><span class="cov8" title="1">{ push(max) }</span>
        }
        <span class="cov8" title="1">grow(cur)

        pop := func() (int64, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (int64, bool) </span><span class="cov8" title="1">{
                if accept &amp;&amp; last != cur </span><span class="cov0" title="0">{
                        cur = last
                        grow(cur)
                }</span>
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

func shrinkTarget64(min, max int64) int64 <span class="cov8" title="1">{
        if min &lt;= 0 &amp;&amp; 0 &lt;= max </span><span class="cov8" title="1">{ return 0 }</span>
        <span class="cov8" title="1">if min &gt; 0 </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov0" title="0">return max</span>
}
func clamp64(x, min, max int64) int64 <span class="cov8" title="1">{
        if x &lt; min </span><span class="cov0" title="0">{ return min }</span>
        <span class="cov8" title="1">if x &gt; max </span><span class="cov0" title="0">{ return max }</span>
        <span class="cov8" title="1">return x</span>
}
func midpointTowards64(a, b int64) int64 <span class="cov8" title="1">{
        if a == b </span><span class="cov0" title="0">{ return a }</span>
        <span class="cov8" title="1">d := b - a
        step := d / 2
        if step == 0 </span><span class="cov8" title="1">{ if d &gt; 0 </span><span class="cov8" title="1">{ step = 1 }</span> else<span class="cov8" title="1"> { step = -1 }</span> }
        <span class="cov8" title="1">return a + step</span>
}
func stepTowards64(a, b int64) int64 <span class="cov8" title="1">{
        if a == b </span><span class="cov0" title="0">{ return a }</span>
        <span class="cov8" title="1">if b &gt; a </span><span class="cov8" title="1">{ return a + 1 }</span>
        <span class="cov8" title="1">return a - 1</span>
}
func autoRange64(local, fromRunner Size) (int64, int64) <span class="cov8" title="1">{
        M := int64(0)
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                if abs := int64Abs(s.Min); abs &gt; M </span><span class="cov0" title="0">{ M = abs }</span>
                <span class="cov8" title="1">if abs := int64Abs(s.Max); abs &gt; M </span><span class="cov8" title="1">{ M = abs }</span>
        }
        <span class="cov8" title="1">if M == 0 </span><span class="cov0" title="0">{ M = 100 }</span>
        <span class="cov8" title="1">return -M, M</span>
}
func int64Abs(x int) int64 <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov0" title="0">{ return int64(-x) }</span>
        <span class="cov8" title="1">return int64(x)</span>
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package gen

import (
        "fmt"
        "math/rand"
)

// SliceOf gera []T a partir de um gerador de elementos.
// - size.Min/Max controlam o comprimento (padrão Min=0, Max=16).
// Shrink:
//  (1) remover blocos grandes (metade, quarto, …) → remove indices
//  (2) remover elemento isolado (direita→esquerda)
//  (3) tentar shrink nos elementos (propagando accept)
func SliceOf[T any](elem Generator[T], size Size) Generator[[]T] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) ([]T, Shrinker[[]T]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                // defaults
                <span class="cov8" title="1">if size.Min == 0 &amp;&amp; size.Max == 0 </span><span class="cov8" title="1">{
                        size.Min, size.Max = 0, 16
                }</span>
                <span class="cov8" title="1">if sz.Min != 0 || sz.Max != 0 </span><span class="cov8" title="1">{
                        size = sz
                }</span>
                <span class="cov8" title="1">if size.Max &lt; size.Min </span><span class="cov0" title="0">{
                        size.Max = size.Min
                }</span>

                // length
                <span class="cov8" title="1">n := size.Min
                if size.Max &gt; size.Min </span><span class="cov8" title="1">{
                        n += r.Intn(size.Max - size.Min + 1)
                }</span>

                // generate elems + capturar shrinkers
                <span class="cov8" title="1">vals := make([]T, n)
                shks := make([]Shrinker[T], n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        v, s := elem.Generate(r, Size{})
                        vals[i], shks[i] = v, s
                }</span>
                <span class="cov8" title="1">cur := append(([]T)(nil), vals...) // snapshot

                // dedup por “assinatura” textual (ok para teste; evita ciclos)
                seen := map[string]struct{}{sig(cur): {}}
                queue := make([][]T, 0, 64)
                var last []T

                push := func(s []T) </span><span class="cov8" title="1">{
                        k := sig(s)
                        if _, ok := seen[k]; ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">seen[k] = struct{}{}
                        // copiar para não compartilhar backing array
                        cp := append(([]T)(nil), s...)
                        queue = append(queue, cp)</span>
                }

                // remove intervalos [i:j) de cur
                <span class="cov8" title="1">rem := func(base []T, i, j int) []T </span><span class="cov8" title="1">{
                        out := make([]T, 0, len(base)-(j-i))
                        out = append(out, base[:i]...)
                        out = append(out, base[j:]...)
                        return out
                }</span>

                <span class="cov8" title="1">growNeighbors := func(base []T) </span><span class="cov8" title="1">{
                        queue = queue[:0]
                        L := len(base)
                        if L == 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        // (1) remover blocos grandes (binário: metade, quarto, …)
                        <span class="cov8" title="1">chunk := L / 2
                        for chunk &gt;= 1 </span><span class="cov8" title="1">{
                                for i := 0; i+chunk &lt;= L; i += chunk </span><span class="cov8" title="1">{
                                        push(rem(base, i, i+chunk))
                                }</span>
                                <span class="cov8" title="1">chunk /= 2</span>
                        }
                        // (2) remover elemento isolado (R-&gt;L)
                        <span class="cov8" title="1">for i := L - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                push(rem(base, i, i+1))
                        }</span>
                        // (3) shrink dos elementos localmente, mantendo tamanho
                        //     (gera um vizinho por posição com 1 passo de shrink)
                        <span class="cov8" title="1">for i := L - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                if shks == nil || shks[i] == nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if nv, ok := shks[i](false); ok </span><span class="cov8" title="1">{ // false: propondo candidato
                                        cand := append(([]T)(nil), base...)
                                        cand[i] = nv
                                        push(cand)
                                }</span>
                        }
                }
                <span class="cov8" title="1">growNeighbors(cur)

                pop := func() ([]T, bool) </span><span class="cov8" title="1">{
                        if len(queue) == 0 </span><span class="cov8" title="1">{
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov8" title="1">{
                                v := queue[len(queue)-1]
                                queue = queue[:len(queue)-1]
                                return v, true
                        }</span>
                        <span class="cov8" title="1">v := queue[0]
                        queue = queue[1:]
                        return v, true</span>
                }

                <span class="cov8" title="1">return cur, func(accept bool) ([]T, bool) </span><span class="cov8" title="1">{
                        if accept </span><span class="cov8" title="1">{
                                // rebaseia no último candidato aceito
                                if last != nil &amp;&amp; sig(last) != sig(cur) </span><span class="cov8" title="1">{
                                        cur = last
                                        // IMPORTANTe: quando rebaseamos, precisamos regenerar shrinkers
                                        // para manter consistência dos elementos (pode ser caro, mas simples)
                                        shks = make([]Shrinker[T], len(cur))
                                        for i := range cur </span><span class="cov8" title="1">{
                                                // reconstroi shrinker “focal” partindo do valor atual:
                                                v := cur[i]
                                                // truque: crie um gerador Const(v) e peça o shrinker dele (não tem).
                                                // então, melhor: se queremos shrink futuro nos elementos, precisamos
                                                // aceitar que só teremos 1 passo no vizinho (já feito em growNeighbors).
                                                // Para manter simples no MVP, não retemos shrinkers após rebase.
                                                shks[i] = nil
                                                _ = v
                                        }</span>
                                        <span class="cov8" title="1">growNeighbors(cur)</span>
                                }
                        }
                        <span class="cov8" title="1">nxt, ok := pop()
                        if !ok </span><span class="cov8" title="1">{
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">last = nxt
                        return nxt, true</span>
                }
        })
}

// sig cria uma assinatura textual simplificada de um slice genérico.
// Para fins de dedup de shrinking em testes, isso é suficiente.
func sig[T any](s []T) string <span class="cov8" title="1">{ return fmt.Sprintf("%#v", s) }</span>

</pre>
		
		<pre class="file" id="file9" style="display: none">package gen

import (
        "math/rand"
        "unicode/utf8"
)

// Atalhos de alfabetos comuns (ASCII puro pra evitar surpresas)
const (
        AlphabetLower   = "abcdefghijklmnopqrstuvwxyz"
        AlphabetUpper   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        AlphabetAlpha   = AlphabetLower + AlphabetUpper
        AlphabetDigits  = "0123456789"
        AlphabetAlphaNum = AlphabetAlpha + AlphabetDigits
        AlphabetASCII   = AlphabetAlphaNum + " !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_{|}~"
)

// String gera strings usando um alfabeto (conjunto de runas) e um Size.
// - Se size.Min/Max = 0, usa padrão: Min=0, Max=32.
// - Se alphabet vazio, usa AlphabetAlphaNum.
func String(alphabet string, size Size) Generator[string] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (string, Shrinker[string]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{
                        r = rand.New(rand.NewSource(rand.Int63()))
                }</span>
                // defaults
                <span class="cov8" title="1">if len(alphabet) == 0 </span><span class="cov0" title="0">{
                        alphabet = AlphabetAlphaNum
                }</span>
                <span class="cov8" title="1">if size.Min == 0 &amp;&amp; size.Max == 0 </span><span class="cov0" title="0">{
                        size.Min, size.Max = 0, 32
                }</span>
                <span class="cov8" title="1">if sz.Min != 0 || sz.Max != 0 </span><span class="cov0" title="0">{ // permitir override externo
                        size = sz
                }</span>
                <span class="cov8" title="1">if size.Max &lt; size.Min </span><span class="cov0" title="0">{
                        size.Max = size.Min
                }</span>

                // generate
                <span class="cov8" title="1">n := size.Min
                if size.Max &gt; size.Min </span><span class="cov8" title="1">{
                        n += r.Intn(size.Max - size.Min + 1)
                }</span>
                <span class="cov8" title="1">b := make([]rune, n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        b[i] = rune(alphabet[r.Intn(len(alphabet))])
                }</span>
                <span class="cov8" title="1">cur := string(b)

                // ---- shrinking: multi-ramo (BFS/DFS) com dedup ----
                type neighbor = string
                queue := make([]neighbor, 0, 64)
                seen := map[string]struct{}{cur: {}}
                var last string

                push := func(s string) </span><span class="cov8" title="1">{
                        if _, ok := seen[s]; ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">seen[s] = struct{}{}
                        queue = append(queue, s)</span>
                }

                // heurística:
                // (1) encurtar (remover sufixo)
                // (2) substituir caracteres por “mais simples” (primeiro da tabela; ex.: 'a' ou '0')
                <span class="cov8" title="1">growNeighbors := func(base string) </span><span class="cov8" title="1">{
                        queue = queue[:0]
                        // (1) encurtar vários passos de uma vez (gerar vários comprimentos)
                        if len(base) &gt; 0 </span><span class="cov8" title="1">{
                                for newLen := len(base) - 1; newLen &gt;= 0; newLen-- </span><span class="cov8" title="1">{
                                        push(base[:newLen])
                                }</span>
                        }
                        // (2) amansar caracteres para o primeiro do alfabeto
                        <span class="cov8" title="1">if len(base) &gt; 0 </span><span class="cov8" title="1">{
                                target := rune(alphabet[0]) // ex.: 'a' ou '0'
                                rs := []rune(base)
                                // direita→esquerda para estabilizar logo sufixos
                                for i := len(rs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                        if rs[i] != target </span><span class="cov8" title="1">{
                                                rs2 := make([]rune, len(rs))
                                                copy(rs2, rs)
                                                rs2[i] = target
                                                if s := string(rs2); utf8.ValidString(s) </span><span class="cov8" title="1">{
                                                        push(s)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">growNeighbors(cur)

                pop := func() (string, bool) </span><span class="cov8" title="1">{
                        if len(queue) == 0 </span><span class="cov0" title="0">{
                                return "", false
                        }</span>
                        <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                                v := queue[len(queue)-1]
                                queue = queue[:len(queue)-1]
                                return v, true
                        }</span>
                        <span class="cov8" title="1">v := queue[0]
                        queue = queue[1:]
                        return v, true</span>
                }

                <span class="cov8" title="1">return cur, func(accept bool) (string, bool) </span><span class="cov8" title="1">{
                        if accept </span><span class="cov0" title="0">{
                                if last != "" &amp;&amp; last != cur </span><span class="cov0" title="0">{
                                        cur = last
                                        growNeighbors(cur)
                                }</span>
                        }
                        <span class="cov8" title="1">next, ok := pop()
                        if !ok </span><span class="cov0" title="0">{
                                return "", false
                        }</span>
                        <span class="cov8" title="1">last = next
                        return next, true</span>
                }
        })
}

// Açúcares sintáticos
func StringAlpha(size Size) Generator[string]    <span class="cov8" title="1">{ return String(AlphabetAlpha, size) }</span>
func StringAlphaNum(size Size) Generator[string] <span class="cov8" title="1">{ return String(AlphabetAlphaNum, size) }</span>
func StringDigits(size Size) Generator[string]   <span class="cov8" title="1">{ return String(AlphabetDigits, size) }</span>
func StringASCII(size Size) Generator[string]    <span class="cov8" title="1">{ return String(AlphabetASCII, size) }</span>

</pre>
		
		<pre class="file" id="file10" style="display: none">package gen

import "math/rand"

// Size controla escala/limites dos geradores.
type Size struct{ Min, Max int }

// Shrinker propõe candidatos “menores”.
// Parâmetro accept: true se o candidato ANTERIOR foi aceito (isto é, reproduziu a falha).
// Isso permite ao shrinker “rebasear” e gerar novos vizinhos a partir do novo mínimo.
type Shrinker[T any] func(accept bool) (next T, ok bool)

// Generator é o contrato público.
type Generator[T any] interface {
        Generate(r *rand.Rand, sz Size) (value T, shrink Shrinker[T])
}

var shrinkStrategy = "bfs"
func SetShrinkStrategy(s string) <span class="cov8" title="1">{
        if s == "dfs" </span><span class="cov8" title="1">{
                shrinkStrategy = "dfs"
        }</span> else<span class="cov8" title="1"> {
                shrinkStrategy = "bfs"
        }</span>
}

// Alias (opcional) p/ compat.
type T[T any] = Generator[T]

// Helper para criar um Generator a partir de uma closure.
type GenFunc[T any] struct {
        fn func(r *rand.Rand, sz Size) (T, Shrinker[T])
}

func (g GenFunc[T]) Generate(r *rand.Rand, sz Size) (T, Shrinker[T]) <span class="cov8" title="1">{ return g.fn(r, sz) }</span>

func From[T any](fn func(*rand.Rand, Size) (T, Shrinker[T])) Generator[T] <span class="cov8" title="1">{
        return GenFunc[T]{fn: fn}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package gen

import (
        "math/rand"
)

// Uint gera inteiros sem sinal com faixa automática baseada em Size.
// Se nenhum Size for informado, usa [0, 100].
func Uint(size Size) Generator[uint] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (uint, Shrinker[uint]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">min, max := autoRangeUint(size, sz) // [min,max], min&gt;=0
                if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
                <span class="cov8" title="1">v := min + uint(r.Intn(int(max-min+1)))
                return uintShrinkInit(v, min, max)</span>
        })
}

// UintRange gera uint uniformemente no intervalo [min, max].
func UintRange(min, max uint) Generator[uint] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (uint, Shrinker[uint]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := min + uint(r.Intn(int(max-min+1)))
                return uintShrinkInit(v, min, max)</span>
        })
}

// ---------------- impl / shrinking ----------------

func uintShrinkInit(start, min, max uint) (uint, Shrinker[uint]) <span class="cov8" title="1">{
        cur, last := clampU(start, min, max), clampU(start, min, max)

        queue := make([]uint, 0, 16)
        seen  := map[uint]struct{}{cur: {}}

        push := func(x uint) </span><span class="cov8" title="1">{
                if x &lt; min || x &gt; max </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">if _, ok := seen[x]; ok </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">seen[x] = struct{}{}
                queue = append(queue, x)</span>
        }

        <span class="cov8" title="1">grow := func(base uint) </span><span class="cov8" title="1">{
                queue = queue[:0]
                // (1) alvo natural p/ uint é 0
                if base != 0 </span><span class="cov8" title="1">{ push(0) }</span>
                // (2) bisseções até 0
                <span class="cov8" title="1">if base != 0 </span><span class="cov8" title="1">{
                        next := base / 2
                        if next != base </span><span class="cov8" title="1">{ push(next) }</span>
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8 &amp;&amp; series &gt; 0; i++ </span><span class="cov8" title="1">{
                                series /= 2
                                push(series)
                        }</span>
                }
                // (3) passo unitário em direção a 0
                <span class="cov8" title="1">if base &gt; 0 </span><span class="cov8" title="1">{ push(base - 1) }</span>
                // (4) limites
                <span class="cov8" title="1">if base != min </span><span class="cov8" title="1">{ push(min) }</span>
                <span class="cov8" title="1">if base != max </span><span class="cov8" title="1">{ push(max) }</span>
        }
        <span class="cov8" title="1">grow(cur)

        pop := func() (uint, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov0" title="0">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (uint, bool) </span><span class="cov8" title="1">{
                if accept &amp;&amp; last != cur </span><span class="cov0" title="0">{
                        cur = last
                        grow(cur)
                }</span>
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov0" title="0">{ return 0, false }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

func autoRangeUint(local, fromRunner Size) (uint, uint) <span class="cov8" title="1">{
        M := 0
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                if s.Max &gt; M </span><span class="cov8" title="1">{ M = s.Max }</span>
        }
        <span class="cov8" title="1">if M == 0 </span><span class="cov0" title="0">{ M = 100 }</span>
        <span class="cov8" title="1">return 0, uint(M)</span>
}
func clampU(x, min, max uint) uint <span class="cov8" title="1">{
        if x &lt; min </span><span class="cov0" title="0">{ return min }</span>
        <span class="cov8" title="1">if x &gt; max </span><span class="cov0" title="0">{ return max }</span>
        <span class="cov8" title="1">return x</span>
}

</pre>
		
		<pre class="file" id="file12" style="display: none">package gen

import "math/rand"

// Uint64 gera inteiros sem sinal 64-bit com faixa automática baseada em Size.
// Se nada for informado, usa [0, 100].
func Uint64(size Size) Generator[uint64] <span class="cov8" title="1">{
        return From(func(r *rand.Rand, sz Size) (uint64, Shrinker[uint64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">min, max := autoRangeUint64(size, sz)
                if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
                <span class="cov8" title="1">v := min + uint64(r.Intn(int(max-min+1)))
                return uint64ShrinkInit(v, min, max)</span>
        })
}

// Uint64Range gera uint64 uniformemente no intervalo [min, max] (inclusivo).
func Uint64Range(min, max uint64) Generator[uint64] <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{ min, max = max, min }</span>
        <span class="cov8" title="1">return From(func(r *rand.Rand, _ Size) (uint64, Shrinker[uint64]) </span><span class="cov8" title="1">{
                if r == nil </span><span class="cov0" title="0">{ r = rand.New(rand.NewSource(rand.Int63())) }</span>
                <span class="cov8" title="1">v := min + uint64(r.Intn(int(max-min+1)))
                return uint64ShrinkInit(v, min, max)</span>
        })
}

// ---------------- impl / shrinking ----------------

func uint64ShrinkInit(start, min, max uint64) (uint64, Shrinker[uint64]) <span class="cov8" title="1">{
        cur, last := clampU64(start, min, max), clampU64(start, min, max)

        queue := make([]uint64, 0, 16)
        seen  := map[uint64]struct{}{cur: {}}

        push := func(x uint64) </span><span class="cov8" title="1">{
                if x &lt; min || x &gt; max </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">if _, ok := seen[x]; ok </span><span class="cov8" title="1">{ return }</span>
                <span class="cov8" title="1">seen[x] = struct{}{}
                queue = append(queue, x)</span>
        }

        <span class="cov8" title="1">grow := func(base uint64) </span><span class="cov8" title="1">{
                queue = queue[:0]
                // (1) alvo natural p/ uint64 é 0
                if base != 0 </span><span class="cov8" title="1">{ push(0) }</span>
                // (2) bisseções rumo a 0
                <span class="cov8" title="1">if base != 0 </span><span class="cov8" title="1">{
                        next := base / 2
                        if next != base </span><span class="cov8" title="1">{ push(next) }</span>
                        <span class="cov8" title="1">series := next
                        for i := 0; i &lt; 8 &amp;&amp; series &gt; 0; i++ </span><span class="cov8" title="1">{
                                series /= 2
                                push(series)
                        }</span>
                }
                // (3) passo unitário
                <span class="cov8" title="1">if base &gt; 0 </span><span class="cov8" title="1">{ push(base - 1) }</span>
                // (4) limites
                <span class="cov8" title="1">if base != min </span><span class="cov8" title="1">{ push(min) }</span>
                <span class="cov8" title="1">if base != max </span><span class="cov8" title="1">{ push(max) }</span>
        }
        <span class="cov8" title="1">grow(cur)

        pop := func() (uint64, bool) </span><span class="cov8" title="1">{
                if len(queue) == 0 </span><span class="cov8" title="1">{ return 0, false }</span>
                <span class="cov8" title="1">if shrinkStrategy == "dfs" </span><span class="cov8" title="1">{
                        v := queue[len(queue)-1]
                        queue = queue[:len(queue)-1]
                        return v, true
                }</span>
                <span class="cov8" title="1">v := queue[0]
                queue = queue[1:]
                return v, true</span>
        }

        <span class="cov8" title="1">return cur, func(accept bool) (uint64, bool) </span><span class="cov8" title="1">{
                if accept &amp;&amp; last != cur </span><span class="cov8" title="1">{
                        cur = last
                        grow(cur)
                }</span>
                <span class="cov8" title="1">nxt, ok := pop()
                if !ok </span><span class="cov8" title="1">{ return 0, false }</span>
                <span class="cov8" title="1">last = nxt
                return nxt, true</span>
        }
}

func autoRangeUint64(local, fromRunner Size) (uint64, uint64) <span class="cov8" title="1">{
        M := 0
        for _, s := range []Size{local, fromRunner} </span><span class="cov8" title="1">{
                if s.Max &gt; M </span><span class="cov8" title="1">{ M = s.Max }</span>
        }
        <span class="cov8" title="1">if M == 0 </span><span class="cov8" title="1">{ M = 100 }</span>
        <span class="cov8" title="1">return 0, uint64(M)</span>
}
func clampU64(x, min, max uint64) uint64 <span class="cov8" title="1">{
        if x &lt; min </span><span class="cov8" title="1">{ return min }</span>
        <span class="cov8" title="1">if x &gt; max </span><span class="cov8" title="1">{ return max }</span>
        <span class="cov8" title="1">return x</span>
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
